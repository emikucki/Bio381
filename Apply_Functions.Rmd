---
title: "Apply Functions"
author: ""
date: ""
output: html_document
---
###Apply functions
```{r}
#The apply function format

# apply(x, margin, function, ....)
# x = vector, matrix or an array (atomic types)
# margin = 1 for rows, 2 for columns, (3....); c(1,2)
# .... = other arguments to the function

m <- matrix(1:12, 3,4, byrow=TRUE)
print(m)

myCV <- function(x=runif(5)) {
  x <- sd(x)/mean(x) # coefficient of variation
  return(x)
}

#get cvs of rows with a for loop
myOut <- vector(mode="numeric", length=nrow(m))
for(i in 1:nrow(m)) {
  myOut[i] <- myCV(m[i,])
}
print(myOut)

#solve with apply function

mO <- apply(m, 1, myCV)
print(mO)

#solve for columns
mO <- apply(m, 2, myCV)
print(mO)

#apply across both indices simultaneously 
mO <- apply(m,c(1,2),myCV) #what is being passed through the function to be operated on?
print(mO)

#use myCV for entire matrix
mO <- myCV(m)
print(mO) #coefficient of variation for all the elements together 

#use an anonymous function 
mO <- apply(m, 1, function(x) sd(x)/mean(x))
print(mO)

#problem with matrix dimensions
#a simple rescaling of column totals

mO <- apply(m,2, function(x) x/sum(x))
print(mO)

#now try over the rows
mO <- apply(m,1, function(x) x/sum(x))
print(mO)
#dimensions of the matrix have flipped- not what we wanted!

#need to apply the 't' function/transpose
mO <- t(apply(m,1, function(x) x/sum(x)))
print(mO)

#rescale over the entire matrix 
mO <- t(apply(m,c(1,2), function(x) x/sum(x)))
print(mO)

#vectorize this operation
mO <- m/sum(m)
print(mO)

#reshuffle matrix rows as in EcoSimR sim2
mO <- t(apply(m,1, function(x) sample(x)))
print(mO)


#reshuffle columns
mO <- apply(m,2, function(x) sample(x))
print(mO)


#shuffle all elements 
mO <- sample(m)
print(mO)

mO <- matrix(sample(m),3,4, byrow=TRUE)
print(mO)

mO <- m
print(mO)
mO[,] <- sample(m)
print(mO)

#what if the output differs in length each time
print(m)
mO <- apply(m, c(1,2), function(x) runif(x))
print(mO)
str(mO)
#made a list of 12 elements; 12 cells of the matrix 

print(mO[1,1])
print(mO[1,2])
print(mO[[2]])

#replicate function
#format
# replicate(n, expression, simplify[true or false])
# n = number of replicates
# expression = r expression
# simplify TRUE --> vector, matrix; FALSE --> list

myOut <- matrix(data=0,3,5)

#fill with a double for loop
for(i in 1:nrow(myOut)) {
  for(j in 1:ncol(myOut)) {
    myOut[i,j] <- runif(1)
  }
}
print(myOut)

myOut <- matrix(data=runif(15), 3, 5)
print(myOut)

#with replicate
mO <- replicate(5, 100 + runif(3))
print(mO)

mO <- replicate(5, 100 + runif(3), simplify = FALSE)
print(mO) #now in list format

#create different structure
mO <- replicate(5, 100 + runif(sample.int(10,1)),simplify = TRUE)
print(mO) #list of 5 elements (of different length)

#the lapply function
#lapply(x, func, ...)
# x = vector or a list
#use with operations on the columns of a data frame

d <- read.table(file="antcountydata.csv", 
                header=TRUE, 
                sep=","
                ,stringsAsFactors = FALSE) 

str(d)

# with a for loop, get mean of var 5 and 6

myMeans <- vector(mode="numeric", length=2)

z<- 0 #have to create counter variabe; ugh!

for (i in 5:6){
  z <- z + 1
  myMeans[z] <- mean(d[[i]])
}
print(myMeans)

#do this much more easily with lapply 
myMeans <- lapply(d[c(5,6)],mean)
print(myMeans) #comes back as list 
unlist(myMeans) #get 2-named values

#sapply is the same but gives output as vectors
myMeans <- sapply(d[c(5,6)],mean)
print(myMeans)

#aggregate function to split a list into groups 
#and apply the function to each group
#aggregate(x, by, fun)
#by = must be in form of a list

myMeans <- aggregate(d[c(5,6)],by=list(d$ecoregion),mean)
print(myMeans)

#map function
# set up parameter sweep for species-area model
# first illustrate with for loop

# global variables
c <- c(0.1, 0.2, 0.5)
z <- c(0.16, 0.26)
A <- c(1,10,100,1000)
noise <- c(0,0.01,0.1)
nrep <- 100 # must be of length 1 to use the Map function

# set up parameter/output grid
modelSum <- expand.grid(nrep=nrep,c=c,z=z,A=A,noise=noise)
modelSum$meanS <- NA
modelSum$sdS <- NA
print(modelSum)
# create simple Species Area calculator function
SAcalc <- function(c=0.1,z=0.16,A=100,noise=0.1) {
  S <- c*(A)^z + rnorm(n=1,mean=0,sd=noise)
  return(S)
}
SAcalc()
# cycle through parameters with a for loop
for (i in 1:nrow(modelSum)) {
  pars <- list(modelSum[i,2],
               modelSum[i,3],
               modelSum[i,4],
               modelSum[i,5])
  temp <-replicate(n=modelSum[i,1],do.call(SAcalc,pars))
  modelSum$meanS[i] <- mean(temp)
  modelSum$sdS[i]<- sd(temp)
}  
print(modelSum) 

# illustrate the basic map function
Map(SAcalc,modelSum$c,modelSum$z,modelSum$A,modelSum$noise)
#list that has 72 elements created by sweeping through corresponding parameters

# now repeat model calculations using only map, no for loops
temp <- replicate(nrep,unlist(Map(SAcalc,modelSum$c,modelSum$z,modelSum$A,modelSum$noise)))
modelSum$meanS[i] <- mean(temp)
modelSum$sdS[i]<- sd(temp)
print(modelSum) 
```